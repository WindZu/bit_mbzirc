///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.05
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif

#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include "HalconCpp.h"
#include <string>
#include <iostream>
#include <stdlib.h>
#include "ros/ros.h"
#include <sstream>
#include <math.h>
#include "halcon_image.h"
#include "sensor_msgs/Image.h"
#include "std_msgs/Empty.h"
#include "bit_vision/LocateInfo.h"

using namespace std;
using namespace HalconCpp;

ros::Publisher pub;
bit_vision::LocateInfo bricklocateInfo;
// Procedure declarations 
// Local procedures 
void classify (HObject ho_Regions, HTuple hv_MLPHandle, HTuple *hv_Classes);
// Short Description: compute texture features on multiple pyramid levels 
void gen_features (HObject ho_Image, HTuple *hv_FeatureVector);
// Short Description: compute various texture features and append them to input feature vector 
void gen_sobel_features (HObject ho_Image, HTuple hv_Features, HTuple *hv_FeaturesExtended);
void get_features (HObject ho_Region, HTuple *hv_Features);
void segment (HObject ho_Image, HObject *ho_Regions);

// Procedures 
// Local procedures 
void classify (HObject ho_Regions, HTuple hv_MLPHandle, HTuple *hv_Classes)
{

  // Local iconic variables
  HObject  ho_Region;

  // Local control variables
  HTuple  hv_Number, hv_J, hv_Features, hv_Class;
  HTuple  hv_Confidence;

  CountObj(ho_Regions, &hv_Number);
  (*hv_Classes) = HTuple();
  {
  HTuple end_val2 = hv_Number;
  HTuple step_val2 = 1;
  for (hv_J=1; hv_J.Continue(end_val2, step_val2); hv_J += step_val2)
  {
    SelectObj(ho_Regions, &ho_Region, hv_J);
    get_features(ho_Region, &hv_Features);
    ClassifyClassMlp(hv_MLPHandle, hv_Features, 1, &hv_Class, &hv_Confidence);
    (*hv_Classes) = (*hv_Classes).TupleConcat(hv_Class);
  }
  }
  return;
}

// Short Description: compute texture features on multiple pyramid levels 
void gen_features (HObject ho_Image, HTuple *hv_FeatureVector)
{

  // Local iconic variables
  HObject  ho_Zoomed1;

  (*hv_FeatureVector) = HTuple();
  //Compute features.
  gen_sobel_features(ho_Image, (*hv_FeatureVector), &(*hv_FeatureVector));
  //Downscale the image (image pyramid) and compute features.
  ZoomImageFactor(ho_Image, &ho_Zoomed1, 0.5, 0.5, "constant");
  gen_sobel_features(ho_Zoomed1, (*hv_FeatureVector), &(*hv_FeatureVector));
  //Uncomment lines to use further pyramid levels:
  //zoom_image_factor (Zoomed1, Zoomed2, 0.5, 0.5, 'constant')
  //gen_sobel_features (Zoomed2, FeatureVector, FeatureVector)
  //zoom_image_factor (Zoomed2, Zoomed3, 0.5, 0.5, 'constant')
  //gen_sobel_features (Zoomed3, FeatureVector, FeatureVector)
  //zoom_image_factor (Zoomed3, Zoomed4, 0.5, 0.5, 'constant')
  //gen_sobel_features (Zoomed4, FeatureVector, FeatureVector)
  (*hv_FeatureVector) = (*hv_FeatureVector).TupleReal();
  return;
}

// Short Description: compute various texture features and append them to input feature vector 
void gen_sobel_features (HObject ho_Image, HTuple hv_Features, HTuple *hv_FeaturesExtended)
{

  // Local iconic variables
  HObject  ho_EdgeAmplitude;

  // Local control variables
  HTuple  hv_Energy, hv_Correlation, hv_Homogeneity;
  HTuple  hv_Contrast, hv_AbsoluteHistoEdgeAmplitude;

  //Coocurrence matrix for 90 deg:
  CoocFeatureImage(ho_Image, ho_Image, 6, 90, &hv_Energy, &hv_Correlation, &hv_Homogeneity, 
      &hv_Contrast);
  //Absolute histogram of edge amplitudes:
  SobelAmp(ho_Image, &ho_EdgeAmplitude, "sum_abs", 3);
  GrayHistoAbs(ho_EdgeAmplitude, ho_EdgeAmplitude, 8, &hv_AbsoluteHistoEdgeAmplitude);
  //
  //You could of course compute more features:
  //Entropy and anisotropy:
  //entropy_gray (Image, Image, Entropy, Anisotropy)
  //Absolute histogram of gray values:
  //gray_histo_abs (Image, Image, 8, AbsoluteHistoImage)
  //Add features to feature vector:
  (*hv_FeaturesExtended).Clear();
  (*hv_FeaturesExtended).Append(hv_Features);
  (*hv_FeaturesExtended).Append(hv_Energy);
  (*hv_FeaturesExtended).Append(hv_Correlation);
  (*hv_FeaturesExtended).Append(hv_Homogeneity);
  (*hv_FeaturesExtended).Append(hv_Contrast);
  (*hv_FeaturesExtended) = (*hv_FeaturesExtended).TupleConcat(hv_AbsoluteHistoEdgeAmplitude);
  //Activate the following lines to add the additional features you activated:
  //FeaturesExtended := [FeaturesExtended,Entropy,Anisotropy]
  //FeaturesExtended := [FeaturesExtended,AbsoluteHistoImage]
  return;
}

void get_features (HObject ho_Region, HTuple *hv_Features)
{

  // Local iconic variables
  HObject  ho_SingleRegion;

  // Local control variables
  HTuple  hv_Circularity, hv_Distance, hv_Sigma;
  HTuple  hv_Roundness, hv_Sides, hv_PSI1, hv_PSI2, hv_PSI3;
  HTuple  hv_PSI4;

  SelectObj(ho_Region, &ho_SingleRegion, 1);
  Circularity(ho_SingleRegion, &hv_Circularity);
  Roundness(ho_SingleRegion, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
  MomentsRegionCentralInvar(ho_SingleRegion, &hv_PSI1, &hv_PSI2, &hv_PSI3, &hv_PSI4);
  (*hv_Features).Clear();
  (*hv_Features).Append(hv_Circularity);
  (*hv_Features).Append(hv_Roundness);
  (*hv_Features).Append(hv_PSI1);
  (*hv_Features).Append(hv_PSI2);
  (*hv_Features).Append(hv_PSI3);
  (*hv_Features).Append(hv_PSI4);
  return;
}

void segment (HObject ho_Image, HObject *ho_Regions)
{

  // Local iconic variables
  HObject  ho_Region, ho_ConnectedRegions;

  // Local control variables
  HTuple  hv_UsedThreshold;

  BinaryThreshold(ho_Image, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);
  Connection(ho_Region, &ho_ConnectedRegions);
  FillUp(ho_ConnectedRegions, &(*ho_Regions));
  return;
}

static HTuple color_result;

// Main procedure 
void action(HObject Image)
{

  // Local iconic variables
  HObject  ho_Image0, ho_ClassRegions, ho_ClassRed;
  HObject  ho_ClassGreen, ho_ClassBLue, ho_ConnectedRegions1;
  HObject  ho_ConnectedRegions2, ho_ConnectedRegions3, ho_ObjectSelectedRed;
  HObject  ho_ObjectSelectedGreen, ho_ObjectSelectedBlue;

  // Local control variables
  HTuple  hv_pathFile, hv_MLPHandle, hv_Area1, hv_Row1;
  HTuple  hv_Column1, hv_Indices, hv_num, hv_Area_1, hv_Row_1;
  HTuple  hv_Column_1, hv_Area2, hv_Row2, hv_Column2, hv_Area_2;
  HTuple  hv_Row_2, hv_Column_2, hv_Area3, hv_Row3, hv_Column3;
  HTuple  hv_Area_3, hv_Row_3, hv_Column_3, hv_areas, hv_index;
  HTuple  hv_class;

  //读入训练好的分割mlp模型
  hv_pathFile = "./src/bit_vision/model/box_segment_mlp.mlp";
  ReadClassMlp(hv_pathFile, &hv_MLPHandle);
  //
  //ReadImage(&ho_Image0, "/media/srt/resource/Project_Noven/wx_project/zed_capture/test/red/mix_8.jpg");
  ClassifyImageClassMlp(Image, &ho_ClassRegions, hv_MLPHandle, 0.9);

  SelectObj(ho_ClassRegions, &ho_ClassRed, 1);
  SelectObj(ho_ClassRegions, &ho_ClassGreen, 2);
  SelectObj(ho_ClassRegions, &ho_ClassBLue, 3);

  Connection(ho_ClassRed, &ho_ConnectedRegions1);
  Connection(ho_ClassGreen, &ho_ConnectedRegions2);
  Connection(ho_ClassBLue, &ho_ConnectedRegions3);

  AreaCenter(ho_ConnectedRegions1, &hv_Area1, &hv_Row1, &hv_Column1);
  TupleSortIndex(hv_Area1, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  SelectObj(ho_ConnectedRegions1, &ho_ObjectSelectedRed, HTuple(hv_Indices[hv_num-1])+1);
  AreaCenter(ho_ObjectSelectedRed, &hv_Area_1, &hv_Row_1, &hv_Column_1);

  AreaCenter(ho_ConnectedRegions2, &hv_Area2, &hv_Row2, &hv_Column2);
  TupleSortIndex(hv_Area2, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  SelectObj(ho_ConnectedRegions2, &ho_ObjectSelectedGreen, HTuple(hv_Indices[hv_num-1])+1);
  AreaCenter(ho_ObjectSelectedGreen, &hv_Area_2, &hv_Row_2, &hv_Column_2);

  AreaCenter(ho_ConnectedRegions3, &hv_Area3, &hv_Row3, &hv_Column3);
  TupleSortIndex(hv_Area3, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  SelectObj(ho_ConnectedRegions3, &ho_ObjectSelectedBlue, HTuple(hv_Indices[hv_num-1])+1);
  AreaCenter(ho_ObjectSelectedBlue, &hv_Area_3, &hv_Row_3, &hv_Column_3);

  //比较3种region的面积 面积最大的作为分类结果
  hv_areas.Clear();
  hv_areas.Append(hv_Area_1);
  hv_areas.Append(hv_Area_2);
  hv_areas.Append(hv_Area_3);
  TupleSortIndex(hv_areas, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  hv_index = HTuple(hv_Indices[hv_num-1]);

  if (0 != (hv_index==0))
  {
    hv_class = "red";
  }
  else if (0 != (hv_index==1))
  {
    hv_class = "green";
  }
  else if (0 != (hv_index==2))
  {
    hv_class = "blue";
  }

  color_result = hv_class;

  bricklocateInfo.header.stamp = ros::Time().now();
  bricklocateInfo.header.frame_id = "brick info";

  bricklocateInfo.flag = true;
  bricklocateInfo.BrickType = color_result.S();
  bricklocateInfo.position.x = 0;
  bricklocateInfo.position.y = 0;
  bricklocateInfo.position.z = 0;

  pub.publish(bricklocateInfo);
}

void imageLeftRectifiedCallback(const sensor_msgs::Image::ConstPtr& msg) 
{
    
    //初始化halcon对象
    HObject  ho_Image;
    //获取halcon-bridge图像指针
    halcon_bridge::HalconImagePtr halcon_bridge_imagePointer = halcon_bridge::toHalconCopy(msg);
    ho_Image = *halcon_bridge_imagePointer->image;
    
    action(ho_Image);

}


int main(int argc, char *argv[])
{
  int ret = 0;

  ros::init(argc, argv, "brick_locate");

  ros::NodeHandle nh; //定义ros句柄

  try
  {
    ros::Subscriber subLeftRectified  = nh.subscribe("/zed/zed_node/left/image_rect_color", 10,imageLeftRectifiedCallback);
    pub = nh.advertise<bit_vision::LocateInfo>("LocateResult", 10);
    
    ros::spin();
  }
  catch (HException &exception)
  {
    ROS_ERROR("  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}



