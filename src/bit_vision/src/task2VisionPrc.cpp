///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.05
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif

#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include "HalconCpp.h"
#include <string>
#include <iostream>
#include <stdlib.h>
#include "ros/ros.h"
#include <sstream>
#include <math.h>
#include "halcon_image.h"
#include "sensor_msgs/Image.h"
#include "std_msgs/Empty.h"
#include "tf/transform_broadcaster.h"
#include "bit_vision/VisionProc.h"
#include <opencv2/core/core.hpp>

#include<iostream>
#undef Success  
#include<eigen3/Eigen/Core>
#include<eigen3/Eigen/Geometry>
#include <eigen_conversions/eigen_msg.h>


#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>
#include <tf/transform_listener.h>

using namespace std;
using namespace HalconCpp;
using namespace cv;

# define GetBrickPos        1   
# define GetBrickAngle      2
# define GetPutPos          3
# define GetPutAngle        4
# define GetLPose           5
# define NotRun             0
int algorithm = NotRun;     // 当前算法
bool data_flag = false;     // 数据置信度

static HTuple brick_angle;
static string brick_color = "blue";
static HTuple brick_pose;
HTuple Brick_X,Brick_Y,Brick_Z;

// Procedure declarations 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Local procedures 
void classify_color_regions (HObject ho_Image, HObject *ho_RegionSelected, HTuple hv_MLPHandle, 
    HTuple *hv_index, HTuple *hv_row, HTuple *hv_column);
void extract_region_lines (HObject ho_Image, HObject *ho_SelectedContours, HTuple *hv_Number);
void gen_region_contours_lines (HObject ho_region, HObject *ho_SelectedContours, 
    HTuple hv_min1, HTuple hv_max1, HTuple *hv_Number2);
void select_max_area_region (HObject ho_Region, HObject *ho_ObjectSelected, HTuple *hv_Area, 
    HTuple *hv_Row, HTuple *hv_Column);

// Procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Local procedures 
void classify_color_regions (HObject ho_Image, HObject *ho_RegionSelected, HTuple hv_MLPHandle, 
    HTuple *hv_index, HTuple *hv_row, HTuple *hv_column)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_ClassRed, ho_ClassGreen;
  HObject  ho_ClassBLue, ho_ConnectedRegions1, ho_ConnectedRegions2;
  HObject  ho_ConnectedRegions3, ho_ObjectSelectedRed, ho_ObjectSelectedGreen;
  HObject  ho_ObjectSelectedBlue, ho_region1, ho_region2;

  // Local control variables
  HTuple  hv_Area_1, hv_Row_1, hv_Column_1, hv_Area_2;
  HTuple  hv_Row_2, hv_Column_2, hv_Area_3, hv_Row_3, hv_Column_3;
  HTuple  hv_areas, hv_rows, hv_columns, hv_Indices, hv_num;
  HTuple  hv_index2, hv_class;

  ClassifyImageClassMlp(ho_Image, &ho_ClassRegions, hv_MLPHandle, 0.9);

  SelectObj(ho_ClassRegions, &ho_ClassRed, 1);
  SelectObj(ho_ClassRegions, &ho_ClassGreen, 2);
  SelectObj(ho_ClassRegions, &ho_ClassBLue, 3);

  Connection(ho_ClassRed, &ho_ConnectedRegions1);
  Connection(ho_ClassGreen, &ho_ConnectedRegions2);
  Connection(ho_ClassBLue, &ho_ConnectedRegions3);

  select_max_area_region(ho_ConnectedRegions1, &ho_ObjectSelectedRed, &hv_Area_1, 
      &hv_Row_1, &hv_Column_1);
  select_max_area_region(ho_ConnectedRegions2, &ho_ObjectSelectedGreen, &hv_Area_2, 
      &hv_Row_2, &hv_Column_2);
  select_max_area_region(ho_ConnectedRegions3, &ho_ObjectSelectedBlue, &hv_Area_3, 
      &hv_Row_3, &hv_Column_3);

  //比较3种region的面积 面积最大的作为分类结果
  hv_areas.Clear();
  hv_areas.Append(hv_Area_1);
  hv_areas.Append(hv_Area_2);
  hv_areas.Append(hv_Area_3);
  hv_rows.Clear();
  hv_rows.Append(hv_Row_1);
  hv_rows.Append(hv_Row_2);
  hv_rows.Append(hv_Row_3);
  hv_columns.Clear();
  hv_columns.Append(hv_Column_1);
  hv_columns.Append(hv_Column_2);
  hv_columns.Append(hv_Column_3);

  TupleSortIndex(hv_areas, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  (*hv_index) = HTuple(hv_Indices[hv_num-1]);
  hv_index2 = HTuple(hv_Indices[hv_num-2]);

  if (0 != ((*hv_index)==0))
  {
    hv_class = "red";

  }
  else if (0 != ((*hv_index)==1))
  {
    hv_class = "green";

  }
  else if (0 != ((*hv_index)==2))
  {
    hv_class = "blue";

  }
  //选取第一种和第二种区域
  SelectObj(ho_ClassRegions, &ho_region1, (*hv_index)+1);
  SelectObj(ho_ClassRegions, &ho_region2, hv_index2+1);
  ConcatObj(ho_region1, ho_region2, &(*ho_RegionSelected));
  (*hv_row) = HTuple(hv_rows[(*hv_index)]);
  (*hv_column) = HTuple(hv_columns[(*hv_index)]);
  return;
}

void extract_region_lines (HObject ho_Image, HObject *ho_SelectedContours, HTuple *hv_Number)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_ObjectSelected3;
  HObject  ho_ImageReduced, ho_Contours, ho_ContoursSplit;
  HObject  ho_SelectedContours1;

  // Local control variables
  HTuple  hv_PI, hv_Width, hv_Height, hv_pathFile;
  HTuple  hv_MLPHandle, hv_Number2;

  //输入是Image
  hv_PI = 3.14;
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  hv_pathFile = "box_segment_mlp.mlp";
  ReadClassMlp(hv_pathFile, &hv_MLPHandle);
  ClassifyImageClassMlp(ho_Image, &ho_ClassRegions, hv_MLPHandle, 0.5);
  //分割
  //提取的index由颜色分类决定
  SelectObj(ho_ClassRegions, &ho_ObjectSelected3, 3);
  ReduceDomain(ho_Image, ho_ObjectSelected3, &ho_ImageReduced);
  //输出是提取的轮廓
  GenContourRegionXld(ho_ObjectSelected3, &ho_Contours, "border");
  SegmentContoursXld(ho_Contours, &ho_ContoursSplit, "lines", 2, 4, 1);
  CountObj(ho_ContoursSplit, &(*hv_Number));
  hv_Number2 = (*hv_Number);
  while (0 != (hv_Number2!=2))
  {
    SelectContoursXld(ho_ContoursSplit, &(*ho_SelectedContours), "contour_length", 
        hv_Width/6, hv_Width, 0, 0);
    CountObj((*ho_SelectedContours), &hv_Number2);
    SelectContoursXld((*ho_SelectedContours), &ho_SelectedContours1, "direction", 
        (-hv_PI)/6, hv_PI/6, -0.5, 0.5);
    CountObj(ho_SelectedContours1, &hv_Number2);
  }
  return;
}

void gen_region_contours_lines (HObject ho_region, HObject *ho_SelectedContours, 
    HTuple hv_min1, HTuple hv_max1, HTuple *hv_Number2)
{

  // Local iconic variables
  HObject  ho_Contours, ho_SortedContours, ho_Lines;
  HObject  ho_LinesSelected;

  // Local control variables
  HTuple  hv_PI, hv_Number, hv_I;

  hv_PI = 3.14;
  GenContourRegionXld(ho_region, &ho_Contours, "border");
  SegmentContoursXld(ho_Contours, &(*ho_SelectedContours), "lines", 2, 4, 1);
  CountObj((*ho_SelectedContours), &hv_Number);
  //可以根据方向和长度来对边缘线段进行选择
  //可以在循环中选择 直到只有两个线段被选择出来
  (*hv_Number2) = hv_Number;
  while (0 != ((*hv_Number2)!=2))
  {
    SelectContoursXld((*ho_SelectedContours), &(*ho_SelectedContours), "contour_length", 
        hv_min1, hv_max1, 0, 0);
    CountObj((*ho_SelectedContours), &(*hv_Number2));
    SelectContoursXld((*ho_SelectedContours), &(*ho_SelectedContours), "direction", 
        (-hv_PI)/6, hv_PI/6, -0.5, 0.5);
    CountObj((*ho_SelectedContours), &(*hv_Number2));
    //可以增加条件 选出最长的两条直线
    //根据视野进行线段的筛选
    SortContoursXld((*ho_SelectedContours), &ho_SortedContours, "upper_left", "true", 
        "row");
    GenEmptyObj(&ho_Lines);
    for (hv_I=1; hv_I<=2; hv_I+=1)
    {
      SelectObj(ho_SortedContours, &ho_LinesSelected, hv_I);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_LinesSelected, HDevWindowStack::GetActive());
      ConcatObj(ho_LinesSelected, ho_Lines, &ho_Lines);
      CountObj(ho_Lines, &(*hv_Number2));
    }

  }
  return;
}

void select_max_area_region (HObject ho_Region, HObject *ho_ObjectSelected, HTuple *hv_Area, 
    HTuple *hv_Row, HTuple *hv_Column)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Area1, hv_Row1, hv_Column1, hv_Indices;
  HTuple  hv_num;

  AreaCenter(ho_Region, &hv_Area1, &hv_Row1, &hv_Column1);
  TupleSortIndex(hv_Area1, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  SelectObj(ho_Region, &(*ho_ObjectSelected), HTuple(hv_Indices[hv_num-1])+1);
  AreaCenter((*ho_ObjectSelected), &(*hv_Area), &(*hv_Row), &(*hv_Column));
  return;

}


// Main procedure 
void action(HObject ho_Image1)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_BrickRegion;
  HObject  ho_RegionOpening, ho_ImageReduced, ho_brick, ho_SelectedContours;
  HObject  ho_SortedContours, ho_Line1, ho_grayImage, ho_Bright_2;
  HObject  ho_fillRegion, ho_ConnectedRegions2, ho_SelectedRegions;
  HObject  ho_Contours;

  // Local control variables
  HTuple  hv_WindowHandle, hv_pathFile, hv_MLPHandle;
  HTuple  hv_CameraParam, hv_Width, hv_Height, hv_brickcolor;
  HTuple  hv_index, hv_Area, hv_Row, hv_Column, hv_PI, hv_Number;
  HTuple  hv_Attrib, hv_RowBegin, hv_ColBegin, hv_RowEnd;
  HTuple  hv_ColEnd, hv_Nr1, hv_Nc1, hv_Dist1, hv_angle_brick;
  HTuple  hv_rotZ_1, hv_Number2, hv_Phi_2, hv_rot_Z_2;

  //计算最上直线的角度
  dev_update_off();
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  //SetWindowAttr("background_color","black");
  //OpenWindow(0,0,512,512,0,"visible","",&hv_WindowHandle);
  //HDevWindowStack::Push(hv_WindowHandle);
  //读入训练好的分割模型
  hv_pathFile = "/home/srt/test_ws/src/bit_vision/model/box_segment_mlp_retrain.mlp";
  ReadClassMlp(hv_pathFile, &hv_MLPHandle);
  ReadCamPar("/home/srt/test_ws/src/bit_vision/model/campar1.dat", 
      &hv_CameraParam);
  //读入第一张图像 用于识别砖块的轮廓
  GetImageSize(ho_Image1, &hv_Width, &hv_Height);
  /*if (HDevWindowStack::IsOpen())
    DispObj(ho_Image1, HDevWindowStack::GetActive());*/
  try
  {
    ClassifyImageClassMlp(ho_Image1, &ho_ClassRegions, hv_MLPHandle, 0.5);
  //基于先前举起砖块时做的颜色分类结果 先选择砖块对应的区域
  
  if (0 != (brick_color=="red"))
  {
    hv_index = 1;
  }
  else if (0 != (brick_color=="green"))
  {
    hv_index = 2;
  }
  else if (0 != (brick_color=="blue"))
  {
    hv_index = 3;
  }
  SelectObj(ho_ClassRegions, &ho_BrickRegion, hv_index);
  //
  //开闭运算
  OpeningCircle(ho_BrickRegion, &ho_RegionOpening, 3.5);
  AreaCenter(ho_RegionOpening, &hv_Area, &hv_Row, &hv_Column);
  //
  ReduceDomain(ho_Image1, ho_RegionOpening, &ho_ImageReduced);
  //
  GenContourRegionXld(ho_ImageReduced, &ho_brick, "border");

  //*****************************************************************************
  //提取剩余区域的轮廓
  hv_PI = 3.14;
  SegmentContoursXld(ho_brick, &ho_SelectedContours, "lines", 2, 4, 1);
  //
  CountObj(ho_SelectedContours, &hv_Number);
  ROS_INFO("Line Number = %lf",hv_Number.D());
  //如果检测到的直线个数为0 则处理下一张图像
  //根据长度筛选直线
  SelectContoursXld(ho_SelectedContours, &ho_SelectedContours, "contour_length", 
      hv_Width/8, 2*hv_Width, -0.5, 0.5);
  CountObj(ho_SelectedContours, &hv_Number);
  //根据视野进行线段的筛选
  SortContoursXld(ho_SelectedContours, &ho_SortedContours, "upper_left", "true", 
      "row");
  GenEmptyObj(&ho_Line1);
  SelectObj(ho_SortedContours, &ho_Line1, 1);
  //拟合拾取砖块的上边缘直线方程
  GetContourGlobalAttribXld(ho_Line1, "cont_approx", &hv_Attrib);
  if (0 != (hv_Attrib==-1))
  {
    //得到直线上两个点的参数
    FitLineContourXld(ho_Line1, "tukey", 2, 0, 5, 2, &hv_RowBegin, &hv_ColBegin, 
        &hv_RowEnd, &hv_ColEnd, &hv_Nr1, &hv_Nc1, &hv_Dist1);
    //拟合成功!!!此处赋值flag
    data_flag = true;
  }
  //
  hv_angle_brick = hv_Nc1.TupleAtan2(hv_Nr1);
  //约束角度在-pi/2-pi/2区间内
  if (0 != (hv_angle_brick<(-0.5*3.14)))
  {
    hv_angle_brick[0] = 3.14+HTuple(hv_angle_brick[0]);
  }
  else if (0 != (hv_angle_brick>(0.5*3.14)))
  {
    hv_angle_brick[0] = HTuple(hv_angle_brick[0])-3.14;
  }

  //角度需要与三维空间中的位姿建立映射关系
  //此时以弧度为单位
  hv_rotZ_1 = (hv_angle_brick[0]*180)/3.14;
  //*****************************************************************************************************
  //方法二 : 与拾取砖块的过程类似
  //step5:以砖块颜色分割结果作为输入
  Rgb1ToGray(ho_ImageReduced, &ho_grayImage);
  //阈值可能需要具体实验的时候调节一下
  Threshold(ho_grayImage, &ho_Bright_2, 134, 201);
  FillUp(ho_Bright_2, &ho_fillRegion);
  OpeningCircle(ho_fillRegion, &ho_RegionOpening, 5.5);
  Connection(ho_RegionOpening, &ho_ConnectedRegions2);
  CountObj(ho_ConnectedRegions2, &hv_Number2);
  SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions, (HTuple("rectangularity").Append("area")), 
      "and", (HTuple(0.9).Append(80000)), (HTuple(1).Append(1000000)));
  CountObj(ho_SelectedRegions, &hv_Number2);
  //计算矩形的角度
  OrientationRegion(ho_SelectedRegions, &hv_Phi_2);
  //限制角度在-pi/2到pi/2区间内
  if (0 != (hv_Phi_2<(-0.5*3.14)))
  {
    hv_Phi_2[0] = 3.14+HTuple(hv_Phi_2[0]);
  }
  else if (0 != (hv_Phi_2>(0.5*3.14)))
  {
    hv_Phi_2[0] = HTuple(hv_Phi_2[0])-3.14;
  }
  hv_rot_Z_2 = (hv_Phi_2*180)/3.14;
  //提取区域轮廓 计算矩形在相机坐标系下的pose
  GenContourRegionXld(ho_SelectedRegions, &ho_Contours, "border");

 //需要增加判断是否为空(无检测结果)输出单位是角度
  brick_angle = hv_rot_Z_2;
  ROS_INFO("brick_angle = %lf",brick_angle.D());
  //brick_angle = hv_Phi_2;
  Brick_X = 0.0;
  Brick_Y = 0.0;
  Brick_Z = 0.0;
  }

  catch (HException &exception)
  {
    ROS_ERROR("  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    data_flag = false;

    return;
  }
  
  

}


void callback(const sensor_msgs::Image::ConstPtr& LeftImage, const sensor_msgs::Image::ConstPtr& RightImage) 
{
    //初始化halcon对象
    HObject  ho_ImageL, ho_ImageR;
    //获取halcon-bridge图像指针
    halcon_bridge::HalconImagePtr halcon_bridge_imagePointerL = halcon_bridge::toHalconCopy(LeftImage);
    ho_ImageL = *halcon_bridge_imagePointerL->image;
    halcon_bridge::HalconImagePtr halcon_bridge_imagePointerR = halcon_bridge::toHalconCopy(RightImage);
    ho_ImageR = *halcon_bridge_imagePointerR->image;

    /*****************************************************
    *                   开始图像处理程序
    *****************************************************/
    switch (algorithm)
    {
        case GetBrickPos:
            // 处理左图图像
            //action(ho_Image); 
            break;
        case GetBrickAngle:
            /* code for condition */
            break;
        case GetPutPos:
            /* code for condition */
            break;
        case GetPutAngle:
            /* code for condition */
            break;
        case GetLPose:
            /* code for condition */
            break;
        default:
            break;
    }
     
}

bool GetVisionData(bit_vision::VisionProc::Request&  req,
                   bit_vision::VisionProc::Response& res)
{
    ROS_INFO_STREAM("BrickType:["<<req.BrickType<<"], "<<"VisionAlgorithm:["<<req.ProcAlgorithm);
    // 设置视觉处理颜色与算法
    brick_color = req.BrickType;
    algorithm = req.ProcAlgorithm;
    data_flag = false;
    ros::Duration(1).sleep();
    if (data_flag)
    {
        // 发布TF   zed_link——>target_link
        static tf::TransformBroadcaster br;
        tf::Transform transform1;
        transform1.setOrigin(tf::Vector3(Brick_X.D(), Brick_Y.D(), Brick_Z.D()));
        tf::Quaternion q;
        q.setRPY(0, 0, brick_angle.D());
        transform1.setRotation(q);
        br.sendTransform(tf::StampedTransform(transform1, ros::Time::now(), "/zed_link", "/target_link"));

        // 获取 zed_link 在 magnet_link下的坐标
        tf::TransformListener listener;
        tf::StampedTransform transform2;

        try{
        listener.lookupTransform("/magnet_link", "/zed_link", ros::Time(0), transform2);
        }
        catch (tf::TransformException ex){
        ROS_ERROR("%s",ex.what());
        ros::Duration(1.0).sleep();
        }

        // 返回目标在末端电磁铁坐标系下的位姿
        res.VisionData.header.stamp = ros::Time().now();
        res.VisionData.header.frame_id = "zed_link";

        res.VisionData.Flag = true;
        res.VisionData.Pose.position.x = transform2.getOrigin().x();
        res.VisionData.Pose.position.y = transform2.getOrigin().x();
        res.VisionData.Pose.position.z = transform2.getOrigin().x();
        res.VisionData.Pose.orientation.x = 0.0;
        res.VisionData.Pose.orientation.y = 0.0;
        res.VisionData.Pose.orientation.z = transform2.getRotation().getZ();

    }
    else    // 如果没有识别结果
    {
        res.VisionData.header.stamp = ros::Time().now();
        res.VisionData.header.frame_id = "zed_link";

        res.VisionData.Flag = false;
        res.VisionData.Pose.position.x = 0.0;
        res.VisionData.Pose.position.y = 0.0;
        res.VisionData.Pose.position.z = 0.0;
        res.VisionData.Pose.orientation.x = 0.0;
        res.VisionData.Pose.orientation.y = 0.0;
        res.VisionData.Pose.orientation.z = 0.0;
    }
}


int main(int argc, char *argv[])
{
  ros::init(argc, argv, "Task2_Vision_node");

  ros::NodeHandle nh("~"); 

  message_filters::Subscriber<sensor_msgs::Image> subleft(nh,"/zed/zed_node/left/image_rect_color",1);
  message_filters::Subscriber<sensor_msgs::Image> subRight(nh,"/zed/zed_node/right/image_rect_color",1);

  message_filters::TimeSynchronizer<sensor_msgs::Image, sensor_msgs::Image> sync(subleft, subleft, 5);
  sync.registerCallback(boost::bind(&callback, _1, _2));

  ros::ServiceServer service = nh.advertiseService("GetVisionData",GetVisionData);

  ROS_INFO_STREAM("Ready to process vision data");

  ros::spin();

  return 0;
}
