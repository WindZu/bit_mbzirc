///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.05
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif

#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include "HalconCpp.h"
#include <string>
#include <iostream>
#include <stdlib.h>
#include "ros/ros.h"
#include <sstream>
#include <math.h>
#include "halcon_image.h"
#include "sensor_msgs/Image.h"
#include "std_msgs/Empty.h"
#include "tf/transform_broadcaster.h"
#include "bit_vision/VisionProc.h"
#include <opencv2/core/core.hpp>

#include<iostream>
#undef Success  
#include<eigen3/Eigen/Core>
#include<eigen3/Eigen/Geometry>
#include <eigen_conversions/eigen_msg.h>


#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>
#include <tf/transform_listener.h>

using namespace std;
using namespace HalconCpp;
using namespace cv;

# define GetBrickPos        1   
# define GetBrickAngle      2
# define GetPutPos          3
# define GetPutAngle        4
# define GetLPose           5
# define NotRun             0
int algorithm = GetBrickPos;     // 当前算法
bool data_flag = false;     // 数据置信度

//取砖和放砖用同一个变量表示角度
HTuple brick_angle(0);
string brick_color = "green";
HTuple Brick_X(0);
HTuple Brick_Y(0);
HTuple Brick_Z(0);
tf::StampedTransform transform_ZedOnBase;

// Procedure declarations 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Local procedures 
void classify_color_regions (HObject ho_Image, HObject *ho_RegionSelected, HTuple hv_MLPHandle, 
    HTuple *hv_index, HTuple *hv_row, HTuple *hv_column);
void extract_region_lines (HObject ho_Image, HObject *ho_SelectedContours, HTuple *hv_Number);
void gen_region_contours_lines (HObject ho_region, HObject *ho_SelectedContours, 
    HTuple hv_min1, HTuple hv_max1, HTuple *hv_Number2);
void select_max_area_region (HObject ho_Region, HObject *ho_ObjectSelected, HTuple *hv_Area, 
    HTuple *hv_Row, HTuple *hv_Column);

// Procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Local procedures 
void classify_color_regions (HObject ho_Image, HObject *ho_RegionSelected, HTuple hv_MLPHandle, 
    HTuple *hv_index, HTuple *hv_row, HTuple *hv_column)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_ClassRed, ho_ClassGreen;
  HObject  ho_ClassBLue, ho_ConnectedRegions1, ho_ConnectedRegions2;
  HObject  ho_ConnectedRegions3, ho_ObjectSelectedRed, ho_ObjectSelectedGreen;
  HObject  ho_ObjectSelectedBlue, ho_region1, ho_region2;

  // Local control variables
  HTuple  hv_Area_1, hv_Row_1, hv_Column_1, hv_Area_2;
  HTuple  hv_Row_2, hv_Column_2, hv_Area_3, hv_Row_3, hv_Column_3;
  HTuple  hv_areas, hv_rows, hv_columns, hv_Indices, hv_num;
  HTuple  hv_index2, hv_class;

  ClassifyImageClassMlp(ho_Image, &ho_ClassRegions, hv_MLPHandle, 0.9);

  SelectObj(ho_ClassRegions, &ho_ClassRed, 1);
  SelectObj(ho_ClassRegions, &ho_ClassGreen, 2);
  SelectObj(ho_ClassRegions, &ho_ClassBLue, 3);

  Connection(ho_ClassRed, &ho_ConnectedRegions1);
  Connection(ho_ClassGreen, &ho_ConnectedRegions2);
  Connection(ho_ClassBLue, &ho_ConnectedRegions3);

  select_max_area_region(ho_ConnectedRegions1, &ho_ObjectSelectedRed, &hv_Area_1, 
      &hv_Row_1, &hv_Column_1);
  select_max_area_region(ho_ConnectedRegions2, &ho_ObjectSelectedGreen, &hv_Area_2, 
      &hv_Row_2, &hv_Column_2);
  select_max_area_region(ho_ConnectedRegions3, &ho_ObjectSelectedBlue, &hv_Area_3, 
      &hv_Row_3, &hv_Column_3);

  //比较3种region的面积 面积最大的作为分类结果
  hv_areas.Clear();
  hv_areas.Append(hv_Area_1);
  hv_areas.Append(hv_Area_2);
  hv_areas.Append(hv_Area_3);
  hv_rows.Clear();
  hv_rows.Append(hv_Row_1);
  hv_rows.Append(hv_Row_2);
  hv_rows.Append(hv_Row_3);
  hv_columns.Clear();
  hv_columns.Append(hv_Column_1);
  hv_columns.Append(hv_Column_2);
  hv_columns.Append(hv_Column_3);

  TupleSortIndex(hv_areas, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  (*hv_index) = HTuple(hv_Indices[hv_num-1]);
  hv_index2 = HTuple(hv_Indices[hv_num-2]);

  if (0 != ((*hv_index)==0))
  {
    hv_class = "red";

  }
  else if (0 != ((*hv_index)==1))
  {
    hv_class = "green";

  }
  else if (0 != ((*hv_index)==2))
  {
    hv_class = "blue";

  }
  //选取第一种和第二种区域
  SelectObj(ho_ClassRegions, &ho_region1, (*hv_index)+1);
  SelectObj(ho_ClassRegions, &ho_region2, hv_index2+1);
  ConcatObj(ho_region1, ho_region2, &(*ho_RegionSelected));
  (*hv_row) = HTuple(hv_rows[(*hv_index)]);
  (*hv_column) = HTuple(hv_columns[(*hv_index)]);
  return;
}

void extract_region_lines (HObject ho_Image, HObject *ho_SelectedContours, HTuple *hv_Number)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_ObjectSelected3;
  HObject  ho_ImageReduced, ho_Contours, ho_ContoursSplit;
  HObject  ho_SelectedContours1;

  // Local control variables
  HTuple  hv_PI, hv_Width, hv_Height, hv_pathFile;
  HTuple  hv_MLPHandle, hv_Number2;

  //输入是Image
  hv_PI = 3.14;
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  hv_pathFile = "box_segment_mlp.mlp";
  ReadClassMlp(hv_pathFile, &hv_MLPHandle);
  ClassifyImageClassMlp(ho_Image, &ho_ClassRegions, hv_MLPHandle, 0.5);
  //分割
  //提取的index由颜色分类决定
  SelectObj(ho_ClassRegions, &ho_ObjectSelected3, 3);
  ReduceDomain(ho_Image, ho_ObjectSelected3, &ho_ImageReduced);
  //输出是提取的轮廓
  GenContourRegionXld(ho_ObjectSelected3, &ho_Contours, "border");
  SegmentContoursXld(ho_Contours, &ho_ContoursSplit, "lines", 2, 4, 1);
  CountObj(ho_ContoursSplit, &(*hv_Number));
  hv_Number2 = (*hv_Number);
  while (0 != (hv_Number2!=2))
  {
    SelectContoursXld(ho_ContoursSplit, &(*ho_SelectedContours), "contour_length", 
        hv_Width/6, hv_Width, 0, 0);
    CountObj((*ho_SelectedContours), &hv_Number2);
    SelectContoursXld((*ho_SelectedContours), &ho_SelectedContours1, "direction", 
        (-hv_PI)/6, hv_PI/6, -0.5, 0.5);
    CountObj(ho_SelectedContours1, &hv_Number2);
  }
  return;
}

void gen_region_contours_lines (HObject ho_region, HObject *ho_SelectedContours, 
    HTuple hv_min1, HTuple hv_max1, HTuple *hv_Number2)
{

  // Local iconic variables
  HObject  ho_Contours, ho_SortedContours, ho_Lines;
  HObject  ho_LinesSelected;

  // Local control variables
  HTuple  hv_PI, hv_Number, hv_I;

  hv_PI = 3.14;
  GenContourRegionXld(ho_region, &ho_Contours, "border");
  SegmentContoursXld(ho_Contours, &(*ho_SelectedContours), "lines", 2, 4, 1);
  CountObj((*ho_SelectedContours), &hv_Number);
  //可以根据方向和长度来对边缘线段进行选择
  //可以在循环中选择 直到只有两个线段被选择出来
  (*hv_Number2) = hv_Number;
  while (0 != ((*hv_Number2)!=2))
  {
    SelectContoursXld((*ho_SelectedContours), &(*ho_SelectedContours), "contour_length", 
        hv_min1, hv_max1, 0, 0);
    CountObj((*ho_SelectedContours), &(*hv_Number2));
    SelectContoursXld((*ho_SelectedContours), &(*ho_SelectedContours), "direction", 
        (-hv_PI)/6, hv_PI/6, -0.5, 0.5);
    CountObj((*ho_SelectedContours), &(*hv_Number2));
    //可以增加条件 选出最长的两条直线
    //根据视野进行线段的筛选
    SortContoursXld((*ho_SelectedContours), &ho_SortedContours, "upper_left", "true", 
        "row");
    GenEmptyObj(&ho_Lines);
    for (hv_I=1; hv_I<=2; hv_I+=1)
    {
      SelectObj(ho_SortedContours, &ho_LinesSelected, hv_I);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_LinesSelected, HDevWindowStack::GetActive());
      ConcatObj(ho_LinesSelected, ho_Lines, &ho_Lines);
      CountObj(ho_Lines, &(*hv_Number2));
    }

  }
  return;
}

void select_max_area_region (HObject ho_Region, HObject *ho_ObjectSelected, HTuple *hv_Area, 
    HTuple *hv_Row, HTuple *hv_Column)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Area1, hv_Row1, hv_Column1, hv_Indices;
  HTuple  hv_num;

  AreaCenter(ho_Region, &hv_Area1, &hv_Row1, &hv_Column1);
  TupleSortIndex(hv_Area1, &hv_Indices);
  hv_num = hv_Indices.TupleLength();
  SelectObj(ho_Region, &(*ho_ObjectSelected), HTuple(hv_Indices[hv_num-1])+1);
  AreaCenter((*ho_ObjectSelected), &(*hv_Area), &(*hv_Row), &(*hv_Column));
  return;

}
//分别把不同任务加过来
// 1.定位圆形标志的位置(二维)
void circle_location(HObject ho_Image,HTuple *hv_x_circle, HTuple *hv_y_circle)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_ClassRegion;
  HObject  ho_ImageReduced, ho_ImageMean, ho_Region, ho_RegionFillUp;
  HObject  ho_ConnectedRegions, ho_RegionErosion, ho_RegionDilation;
  HObject  ho_Objects, ho_ImageReduced2, ho_ImageResult1, ho_ImageResult2;
  HObject  ho_ImageResult3, ho_Edges, ho_ContoursSplit, ho_Circles;
  HObject  ho_Lines, ho_ObjectSelected, ho_SelectedCircles;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_pathFile, hv_MLPHandle, hv_color, hv_index, hv_width_m;
  HTuple  hv_height_m, hv_Number, hv_NumberContours, hv_i;
  HTuple  hv_Attrib, hv_Row, hv_Column, hv_Radius, hv_StartPhi;
  HTuple  hv_EndPhi, hv_PointOrder;
  try
  {
    //鲁棒的定位图像中的圆心,并能根据距离排序,选择距离最近的圆心
    //GetImageSize(ho_Image, &hv_Width, &hv_Height);
    //
    //step1:根据颜色提取指定颜色的砖块区域
    hv_pathFile = "/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/box_segment_mlp_retrain.mlp";
    ReadClassMlp(hv_pathFile, &hv_MLPHandle);
    //分类砖块颜色
    ClassifyImageClassMlp(ho_Image, &ho_ClassRegions, hv_MLPHandle, 0.9);
    //比如接收指令拾取砖块
        if (brick_color=="red")
        {
        hv_index = 1;
        }
        else if (brick_color=="green")
        {
        hv_index = 2;
        }
        else if (brick_color=="blue")
        {
        hv_index = 3;
        }
        else if (brick_color=="orange")
        {
        hv_index = 4;
        }
    SelectObj(ho_ClassRegions, &ho_ClassRegion, hv_index);
    
    //step2: 提取ROI区域用于轮廓提取 此处用特定颜色的分割以及矩形拟合来提取区域
    //
    OpeningCircle(ho_ClassRegion, &ho_ClassRegion, 5.5);
    ReduceDomain(ho_Image, ho_ClassRegion, &ho_ImageReduced);
    //
    MeanImage(ho_ImageReduced, &ho_ImageMean, 20, 20);
    DynThreshold(ho_Image, ho_ImageMean, &ho_Region, 0, "light");
    FillUp(ho_Region, &ho_RegionFillUp);
    Connection(ho_RegionFillUp, &ho_ConnectedRegions);
    ErosionCircle(ho_ConnectedRegions, &ho_RegionErosion, 3.5);
    DilationCircle(ho_RegionErosion, &ho_RegionDilation, 3.5);
    SelectShape(ho_RegionDilation, &ho_Objects, (HTuple("area").Append("convexity")), 
        "and", (HTuple(2000).Append(0.9)), (HTuple(4000000).Append(1)));
    CountObj(ho_Objects, &hv_Number);
    
    //step 3:提取轮廓 拟合圆形
    ReduceDomain(ho_Image, ho_Objects, &ho_ImageReduced2);
    TransFromRgb(ho_ImageReduced2, ho_ImageReduced2, ho_ImageReduced2, &ho_ImageResult1, 
        &ho_ImageResult2, &ho_ImageResult3, "hsv");
    //
    //方法一: 亚像素提取轮廓 选用圆形来拟合轮廓
    EdgesSubPix(ho_ImageResult3, &ho_Edges, "canny", 1.5, 10, 40);
    SegmentContoursXld(ho_Edges, &ho_ContoursSplit, "lines_circles", 0, 4, 2);
    CountObj(ho_ContoursSplit, &hv_NumberContours);
    GenEmptyObj(&ho_Circles);
    GenEmptyObj(&ho_Lines);
    {
    HTuple end_val59 = hv_NumberContours;
    HTuple step_val59 = 1;
    for (hv_i=1; hv_i.Continue(end_val59, step_val59); hv_i += step_val59)
    {
        SelectObj(ho_ContoursSplit, &ho_ObjectSelected, hv_i);
        GetContourGlobalAttribXld(ho_ObjectSelected, "cont_approx", &hv_Attrib);
        if (0 != (hv_Attrib==-1))
        {
        ConcatObj(ho_Lines, ho_ObjectSelected, &ho_Lines);
        }
        else
        {
        ConcatObj(ho_Circles, ho_ObjectSelected, &ho_Circles);
        }
    }
    }
    SelectShapeXld(ho_Circles, &ho_SelectedCircles, "circularity", "and", 0.4, 1);
    FitCircleContourXld(ho_SelectedCircles, "algebraic", -1, 0, 0, 3, 2, &hv_Row, &hv_Column, 
        &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);

    (*hv_x_circle) = hv_Column;
    (*hv_y_circle) = hv_Row;
   
    data_flag = true;
  }
  catch (HException &exception)
  {
    ROS_ERROR("  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    data_flag = false;

    return;
  }
 
}


//2.拾取砖块角度估计
void pick_brick(HObject ho_Image)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_ClassRegion;
  HObject  ho_ImageReduced, ho_grayImage, ho_Bright, ho_fillRegion;
  HObject  ho_RegionOpening, ho_ConnectedRegions2, ho_SelectedRegions;
  HObject  ho_Contours;

  // Local control variables
  HTuple  hv_CamParam, hv_pathFile, hv_MLPHandle;
  HTuple  hv_Width, hv_Height, hv_WindowHandle, hv_color;
  HTuple  hv_index, hv_Number1, hv_Phi, hv_angle, hv_BrickPose;
  HTuple  hv_CovPose, hv_Error;

  try
  {
    //step1 :读入相机标定参数
    ReadCamPar("/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/campar1.dat", &hv_CamParam);
    //step2:读入训练好的分割模型
    hv_pathFile = "/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/box_segment_mlp_retrain.mlp";
    ReadClassMlp(hv_pathFile, &hv_MLPHandle);
    //step3:读图 并 分割图像
    GetImageSize(ho_Image, &hv_Width, &hv_Height);
    //SetWindowAttr("background_color","black");
    //OpenWindow(0,0,hv_Width*0.5,hv_Height*0.5,0,"visible","",&hv_WindowHandle);
    //HDevWindowStack::Push(hv_WindowHandle);
    //分类砖块颜色
    ClassifyImageClassMlp(ho_Image, &ho_ClassRegions, hv_MLPHandle, 0.9);
    //比如接收指令拾取green砖块
    //接收砖块颜色指令
    if (brick_color=="red")
    {
      hv_index = 1;
    }
    else if (brick_color=="green")
    {
      hv_index = 2;
    }
    else if (brick_color=="blue")
    {
      hv_index = 3;
    }
    else if (brick_color=="orange")
    {
      hv_index = 4;
    }

    SelectObj(ho_ClassRegions, &ho_ClassRegion, hv_index);
    //step4: 基于分割结果分割图像并进行开闭运算预处理
    OpeningCircle(ho_ClassRegion, &ho_ClassRegion, 5.5);
    ReduceDomain(ho_Image, ho_ClassRegion, &ho_ImageReduced);
    //step5:以分割结果作为输入
    Rgb1ToGray(ho_ImageReduced, &ho_grayImage);
    //阈值可能需要具体实验的时候调节一下
    Threshold(ho_grayImage, &ho_Bright, 134, 201);
    FillUp(ho_Bright, &ho_fillRegion);
    OpeningCircle(ho_fillRegion, &ho_RegionOpening, 5.5);
    Connection(ho_RegionOpening, &ho_ConnectedRegions2);
    CountObj(ho_ConnectedRegions2, &hv_Number1);

    SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions, (HTuple("rectangularity").Append("area")), 
        "and", (HTuple(0.9).Append(80000)), (HTuple(1).Append(1000000)));
    CountObj(ho_SelectedRegions, &hv_Number1);

    //step6:计算矩形的角度
    //select_shape_std (SelectedRegions, SelectedRegions, 'rectangle2', 90)
    OrientationRegion(ho_SelectedRegions, &hv_Phi);

    //将角度控制在-pi/2到pi/2之间
  if (hv_Phi<(-0.5*3.14)&&hv_Phi>(-3.14))
  {
    hv_Phi[0] = 3.14+HTuple(hv_Phi[0]);
  }
  else if (hv_Phi>(0.5*3.14)&&hv_Phi<3.14)
  {
    hv_Phi[0] = HTuple(hv_Phi[0])-3.14;
  }

    brick_angle = (hv_Phi[0]*180)/3.14;
    ROS_INFO("brick_angle = %lf",brick_angle.D());
    Brick_X = 0.0;//通过圆圈定位
    Brick_Y = 0.0;
    Brick_Z = 0.0;

    data_flag = true;
  }
  catch (HException &exception)
  {
    ROS_ERROR("  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    data_flag = false;

    return;
  }
   
}


// 3.放砖角度估计
void put_brick(HObject ho_Image1)
{

  // Local iconic variables
  HObject  ho_ClassRegions, ho_BrickRegion;
  HObject  ho_RegionOpening, ho_ImageReduced, ho_brick, ho_SelectedContours;
  HObject  ho_SortedContours, ho_Line1, ho_grayImage, ho_Bright_2;
  HObject  ho_fillRegion, ho_ConnectedRegions2, ho_SelectedRegions;
  HObject  ho_Contours;

  // Local control variables
  HTuple  hv_WindowHandle, hv_pathFile, hv_MLPHandle;
  HTuple  hv_CameraParam, hv_Width, hv_Height, hv_brickcolor;
  HTuple  hv_index, hv_Area, hv_Row, hv_Column, hv_PI, hv_Number;
  HTuple  hv_Attrib, hv_RowBegin, hv_ColBegin, hv_RowEnd;
  HTuple  hv_ColEnd, hv_Nr1, hv_Nc1, hv_Dist1, hv_angle_brick;
  HTuple  hv_rotZ_1, hv_Number2, hv_Phi_2, hv_rot_Z_2;

  //计算最上直线的角度
  dev_update_off();
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());

  //读入训练好的分割模型
  hv_pathFile = "/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/box_segment_mlp_retrain.mlp";
  ReadClassMlp(hv_pathFile, &hv_MLPHandle);
  ReadCamPar("/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/campar1.dat", 
      &hv_CameraParam);
  //读入第一张图像 用于识别砖块的轮廓
  GetImageSize(ho_Image1, &hv_Width, &hv_Height);

  try
  {
    ClassifyImageClassMlp(ho_Image1, &ho_ClassRegions, hv_MLPHandle, 0.5);
  //基于先前举起砖块时做的颜色分类结果 先选择砖块对应的区域
  
  if (0 != (brick_color=="red"))
  {
    hv_index = 1;
  }
  else if (0 != (brick_color=="green"))
  {
    hv_index = 2;
  }
  else if (0 != (brick_color=="blue"))
  {
    hv_index = 3;
  }
  SelectObj(ho_ClassRegions, &ho_BrickRegion, hv_index);
  //
  //开闭运算
  OpeningCircle(ho_BrickRegion, &ho_RegionOpening, 3.5);
  AreaCenter(ho_RegionOpening, &hv_Area, &hv_Row, &hv_Column);
  //
  ReduceDomain(ho_Image1, ho_RegionOpening, &ho_ImageReduced);
  //
  GenContourRegionXld(ho_ImageReduced, &ho_brick, "border");

  //*****************************************************************************
  //提取剩余区域的轮廓
  hv_PI = 3.14;
  SegmentContoursXld(ho_brick, &ho_SelectedContours, "lines", 2, 4, 1);
  //
  CountObj(ho_SelectedContours, &hv_Number);
  ROS_INFO("Line Number = %lf",hv_Number.D());
  //如果检测到的直线个数为0 则处理下一张图像
  //根据长度筛选直线
  SelectContoursXld(ho_SelectedContours, &ho_SelectedContours, "contour_length", 
      hv_Width/8, 2*hv_Width, -0.5, 0.5);
  CountObj(ho_SelectedContours, &hv_Number);
  //根据视野进行线段的筛选
  SortContoursXld(ho_SelectedContours, &ho_SortedContours, "upper_left", "true", 
      "row");
  GenEmptyObj(&ho_Line1);
  SelectObj(ho_SortedContours, &ho_Line1, 1);
  //拟合拾取砖块的上边缘直线方程
  GetContourGlobalAttribXld(ho_Line1, "cont_approx", &hv_Attrib);
  if (0 != (hv_Attrib==-1))
  {
    //得到直线上两个点的参数
    FitLineContourXld(ho_Line1, "tukey", 2, 0, 5, 2, &hv_RowBegin, &hv_ColBegin, 
        &hv_RowEnd, &hv_ColEnd, &hv_Nr1, &hv_Nc1, &hv_Dist1);
    //拟合成功!!!此处赋值flag
    data_flag = true;
  }
  //
  hv_angle_brick = hv_Nc1.TupleAtan2(hv_Nr1);
  //约束角度在-pi/2-pi/2区间内
  if (0 != (hv_angle_brick<(-0.5*3.14)))
  {
    hv_angle_brick[0] = 3.14+HTuple(hv_angle_brick[0]);
  }
  else if (0 != (hv_angle_brick>(0.5*3.14)))
  {
    hv_angle_brick[0] = HTuple(hv_angle_brick[0])-3.14;
  }

  //角度需要与三维空间中的位姿建立映射关系
  //此时以弧度为单位
  hv_rotZ_1 = (hv_angle_brick[0]*180)/3.14;
  //*****************************************************************************************************
  //方法二 : 与拾取砖块的过程类似
  //step5:以砖块颜色分割结果作为输入
  Rgb1ToGray(ho_ImageReduced, &ho_grayImage);
  //阈值可能需要具体实验的时候调节一下
  Threshold(ho_grayImage, &ho_Bright_2, 134, 201);
  FillUp(ho_Bright_2, &ho_fillRegion);
  OpeningCircle(ho_fillRegion, &ho_RegionOpening, 5.5);
  Connection(ho_RegionOpening, &ho_ConnectedRegions2);
  CountObj(ho_ConnectedRegions2, &hv_Number2);
  SelectShape(ho_ConnectedRegions2, &ho_SelectedRegions, (HTuple("rectangularity").Append("area")), 
      "and", (HTuple(0.9).Append(80000)), (HTuple(1).Append(1000000)));
  CountObj(ho_SelectedRegions, &hv_Number2);
  //计算矩形的角度
  OrientationRegion(ho_SelectedRegions, &hv_Phi_2);
  //限制角度在-pi/2到pi/2区间内
  if (0 != (hv_Phi_2<(-0.5*3.14)))
  {
    hv_Phi_2[0] = 3.14+HTuple(hv_Phi_2[0]);
  }
  else if (0 != (hv_Phi_2>(0.5*3.14)))
  {
    hv_Phi_2[0] = HTuple(hv_Phi_2[0])-3.14;
  }
  hv_rot_Z_2 = (hv_Phi_2*180)/3.14;
  //提取区域轮廓 计算矩形在相机坐标系下的pose
  GenContourRegionXld(ho_SelectedRegions, &ho_Contours, "border");

 //需要增加判断是否为空(无检测结果)输出单位是角度
  brick_angle = hv_rot_Z_2;
  ROS_INFO("brick_angle = %lf",brick_angle.D());
  //brick_angle = hv_Phi_2;
  Brick_X = 0.0;
  Brick_Y = 0.0;
  Brick_Z = 0.0;
  }

  catch (HException &exception)
  {
    ROS_ERROR("  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    data_flag = false;

    return;
  }

}

//4.定义根据标定参数 定位三维点的函数
//注意输入的顺序:行是纵坐标,列是横坐标
int stero_location(HTuple row_L, HTuple column_L, HTuple row_R, HTuple column_R,
HTuple *hv_X, HTuple *hv_Y, HTuple *hv_Z)
{
   
  HTuple  hv_CameraParameters1,hv_CameraParameters2, hv_RealPose;
  HTuple  hv_Dist;
  
  //三维定位
    
    ReadCamPar("/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/campar1.dat", &hv_CameraParameters1);
    ReadCamPar("/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/campar2.dat", &hv_CameraParameters2);
    ReadPose("/home/ugvcontrol/bit_mbzirc/src/bit_vision/model/relpose.dat", &hv_RealPose);

    IntersectLinesOfSight(hv_CameraParameters2, hv_CameraParameters2, hv_RealPose, 
    row_L, column_L, row_R, column_R, hv_X, hv_Y, hv_Z, &hv_Dist);
    return 0;
 }

//初始化halcon对象
HObject  ho_ImageL, ho_ImageR;

//回调函数
void callback(const sensor_msgs::Image::ConstPtr& LeftImage, const sensor_msgs::Image::ConstPtr& RightImage) 
{
    
    //获取halcon-bridge图像指针
    halcon_bridge::HalconImagePtr halcon_bridge_imagePointerL = halcon_bridge::toHalconCopy(LeftImage);
    ho_ImageL = *halcon_bridge_imagePointerL->image;
    halcon_bridge::HalconImagePtr halcon_bridge_imagePointerR = halcon_bridge::toHalconCopy(RightImage);
    ho_ImageR = *halcon_bridge_imagePointerR->image;
    
    
    /*****************************************************
    *                   开始图像处理程序
    *****************************************************/
    
    
}

bool GetVisionData(bit_vision::VisionProc::Request&  req,
                   bit_vision::VisionProc::Response& res)
{
    ROS_INFO_STREAM("BrickType:["<<req.BrickType<<"], "<<"VisionAlgorithm:["<<dec<<req.ProcAlgorithm);
    // 设置视觉处理颜色与算法
    brick_color = req.BrickType;
    algorithm = req.ProcAlgorithm;
    data_flag = false;

    HTuple circle_x_L,circle_y_L,circle_x_R,circle_y_R;
    switch (algorithm)
    {
        case GetBrickPos:
            circle_location(ho_ImageL,&circle_x_L,&circle_y_L);
            circle_location(ho_ImageR,&circle_x_R,&circle_y_R);
            stero_location(circle_y_L,circle_x_L,circle_y_R,circle_x_R,&Brick_X,&Brick_Y,&Brick_Z);
            break;
        case GetBrickAngle:
            pick_brick(ho_ImageL); 
            break;
        case GetPutPos:
            //尚未加入L型架检测//目前是定位下面砖的圆形标志
            circle_location(ho_ImageL,&circle_x_L,&circle_y_L);
            circle_location(ho_ImageR,&circle_x_R,&circle_y_R);
            stero_location(circle_y_L,circle_x_L,circle_y_R,circle_x_R,&Brick_X,&Brick_Y,&Brick_Z);
            break;
        case GetPutAngle:
            put_brick(ho_ImageL);
            break;
        case GetLPose:
            put_brick(ho_ImageL);
            break;
        default:
            break;
    }

    if (data_flag)
    {
        tf::Transform transform_TargetOnZed;
        transform_TargetOnZed.setOrigin(tf::Vector3(Brick_X.D(), Brick_Y.D(), Brick_Z.D()));
        tf::Quaternion q;
        q.setRPY(0, 0, brick_angle.D());
        transform_TargetOnZed.setRotation(q);
 
        tf::Transform transform3 = transform_ZedOnBase*transform_TargetOnZed;

        ROS_INFO_STREAM("Vision data:"<<Brick_X.D()<<","<<Brick_Y.D()<<","<<Brick_Z.D());
        
        // 返回目标在末端电磁铁坐标系下的位姿
        res.VisionData.header.stamp = ros::Time().now();
        res.VisionData.header.frame_id = "base_link";

        res.VisionData.Flag = true;
        res.VisionData.Pose.position.x = transform3.getOrigin().x();
        res.VisionData.Pose.position.y = transform3.getOrigin().y();
        res.VisionData.Pose.position.z = transform3.getOrigin().z();
        res.VisionData.Pose.orientation.x = 0.0;
        res.VisionData.Pose.orientation.y = 0.0;
        res.VisionData.Pose.orientation.z = transform3.getRotation().getZ();

    }
    else    // 如果没有识别结果
    {
        res.VisionData.header.stamp = ros::Time().now();
        res.VisionData.header.frame_id = "zed_link";

        res.VisionData.Flag = false;
        res.VisionData.Pose.position.x = 0.0;
        res.VisionData.Pose.position.y = 0.0;
        res.VisionData.Pose.position.z = 0.0;
        res.VisionData.Pose.orientation.x = 0.0;
        res.VisionData.Pose.orientation.y = 0.0;
        res.VisionData.Pose.orientation.z = 0.0;
    }

    algorithm = NotRun;
}


int main(int argc, char *argv[])
{
  ros::init(argc, argv, "Task2_Vision_node");

  ros::NodeHandle nh; 

  message_filters::Subscriber<sensor_msgs::Image> subleft(nh,"/zed/zed_node/left/image_rect_color",1);
  message_filters::Subscriber<sensor_msgs::Image> subRight(nh,"/zed/zed_node/right/image_rect_color",1);

  message_filters::TimeSynchronizer<sensor_msgs::Image, sensor_msgs::Image> sync(subleft, subleft, 5);
  sync.registerCallback(boost::bind(&callback, _1, _2));

  ros::ServiceServer service = nh.advertiseService("GetVisionData",GetVisionData);

  ROS_INFO_STREAM("Ready to process vision data");

  //指定循环的频率 
  ros::Rate loop_rate(20); 
  tf::TransformListener listener;
  
  while(ros::ok()) 
  { 
      // 获取 zed_link 在 base_link下的坐标
      try{
      listener.lookupTransform("base_link", "zed_link", ros::Time(0), transform_ZedOnBase);
      }
      catch (tf::TransformException ex){
      //ROS_ERROR("%s",ex.what());
      ros::Duration(1.0).sleep();
      }
      
      //处理ROS的信息，比如订阅消息,并调用回调函数 
      ros::spinOnce(); 
      loop_rate.sleep(); 
  } 

  //ros::MultiThreadedSpinner spinner(3); // Use 4 threads
  //spinner.spin();
  
  return 0;
}
